---
title: scrapy正则表达式
date: 2017-07-05 22:56:49
tags: scrapy
---

# 基础
为什么学习爬虫要学习正则表达式？

[scrapy总览](/2017/07/04/scrapy总览/)里介绍过，爬虫的基本流程：
```
下载-分析-保存
```

注意，其中分析流程分为两个主要步骤：

1. 结构化网页的node节点分析
1. 节点内文本数据分析

文本数据分析一个最大的利器就是：正则表达式

看吧！！就这么简单，所以说，写爬虫，正则表达式是一个绕不过去的坎。

我们来仔细学习下吧！！！

所有语言都支持正则表达式的文本分析，学习好正则表达式，可以在任何语言里面使用。

正则表达式按照文本的模式匹配，什么叫模式？

可以理解为：模糊的文本的描述，比如:`I am good man, I'm 28 years old`

上python代码：
``` python
import re

someText = "I am good man, I'm 28 years old"
regexPattern = "I am good man, I'm (\d+)"
matchHandle = re.match(regexPattern, someText)
if matchHandle :
    print(matchHandle.group(1))
```

> 输出: 28

正则表达式从最左面开始匹配，`\d`代表一个整数，+表示前面的字符出现一次或者多次(>=1)

`re`是python中的正则表达式的lib，其余是python中语法，我们基于这个再进化下匹配模式字符串：

> .\*(\d+).\*

其中，`.`表示任意字符，`*`表示任意次数，上述输出结果是什么，猜一猜？

> 输出：8

为什么呢？

`()`内部提取的时候，按照最小匹配原则，也就是`+`代表`>=1`，那么`()`就提取1个数字

> .\*\s(\d+).\*

> 输出：28

前面增加`\s`后，则解释为：空格加上最少一个数字，则匹配了`28`，为什么不是`8`了呢？这里就是`贪婪匹配`。

他匹配了能够匹配的最长字符。

怎么破解贪婪匹配？

利器：`?`

> .\*\s?(\d+).\*

> 输出：8


通过上面的例子，我们可以看出来正则匹配的匹配模式可以写多种，匹配模式包含特殊字符（模糊表明查询内容语法），特殊字符在书写的时候参考：

[wiki](http://www.runoob.com/regexp/regexp-syntax.html)

# 特殊字符

## 出现次数&位置限定

1. ^
    - 以XXX开头
1. $
    - 以XXX结尾
1. *
    - 任意次数
1. ?
    - 解除贪婪，有或没有
1. +
    - `>=1`
    - `{1,}`
1. `{1}`
    - `=1`
1. {1,}
    - `>=1`
1. `{1,5}`
    - `>=1 && <= 5`
1. `|`
    - 或，`短路效果`

## 字符限定
1. []
    - 字符限定
1. [^]
    - `^`表示非
1. [a-z]
    - 包含a-z中字符1个

## 特殊含义

1. \s
    - 空格
1. \S
    - 非空格
1. \w
    - [a-zA-Z0-9_]
1. \W
    - 非字符
1. \d
    - 数字
1. [\u4E00-\u9FA5]
    - unicode编码汉字

## 提取

1. ()

# 终极练习题

``` python
# 提取
import re
matches = [
    "张三出生于2001年6月1日",
    "张三出生于2001年6月",
    "张三出生于2001/6/1",
    "张三出生于2001-6-1",
    "张三出生于2001-06-01",
    "张三出生于2001-06",
]
regexPattern = ".*(\d{4}[年/-]\d{1,2}([月/-]\d{1,2}日?|$|月$))"
for match in matches:
    reHandle = re.match(regexPattern, match)
    if reHandle:
        print(reHandle.group(1))
```
``` shell
2001年6月1日
2001年6月
2001/6/1
2001-6-1
2001-06-01
2001-06
```
